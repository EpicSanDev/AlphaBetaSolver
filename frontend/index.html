<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTO Poker Solver</title>
    <link rel="stylesheet" href="styles.css" type="text/css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="api-gateway.js"></script>
    <script src="realtime-monitor.js"></script>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>üÉè GTO Poker Solver</h1>
                <p>Solveur de poker distribu√© avec algorithme CFR+</p>
            </div>
            
            <div class="card">
                <div class="nav-tabs">
                    <button class="nav-tab" :class="{active: activeTab === 'create'}" @click="activeTab = 'create'">
                        Nouvelle Simulation
                    </button>
                    <button class="nav-tab" :class="{active: activeTab === 'monitor'}" @click="activeTab = 'monitor'">
                        Surveillance
                    </button>
                    <button class="nav-tab" :class="{active: activeTab === 'cluster'}" @click="activeTab = 'cluster'">
                        Cluster
                    </button>
                    <button class="nav-tab" :class="{active: activeTab === 'status'}" @click="activeTab = 'status'">
                        Syst√®me
                    </button>
                    <button class="nav-tab" :class="{active: activeTab === 'results'}" @click="activeTab = 'results'">
                        R√©sultats
                    </button>
                    <div class="connection-status">
                        <span class="status-indicator" :class="{connected: isRealtimeConnected, disconnected: !isRealtimeConnected}"></span>
                        <span class="status-text">{{ isRealtimeConnected ? 'Temps r√©el' : 'Hors ligne' }}</span>
                    </div>
                </div>
                
                <!-- Tab: Nouvelle Simulation -->
                <div v-if="activeTab === 'create'">
                    <h3>Cr√©er une nouvelle simulation</h3>
                    
                    <div class="form-group">
                        <label>Type de simulation</label>
                        <select v-model="newSimulation.type" class="form-control">
                            <option value="preflop">Pr√©flop</option>
                            <option value="postflop">Postflop</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Nom (optionnel)</label>
                        <input v-model="newSimulation.name" class="form-control" placeholder="Nom de la simulation">
                    </div>
                    
                    <div class="form-group">
                        <label>Description (optionnelle)</label>
                        <textarea v-model="newSimulation.description" class="form-control" rows="3" placeholder="Description de la simulation"></textarea>
                    </div>
                    
                    <div class="grid">
                        <div>
                            <h4>Configuration du jeu</h4>
                            <div class="form-group">
                                <label>Nombre de joueurs</label>
                                <input v-model.number="newSimulation.gameConfig.numPlayers" type="number" class="form-control" min="2" max="9" value="2">
                            </div>
                            
                            <div class="form-group">
                                <label>Stack size (BB)</label>
                                <input v-model.number="newSimulation.gameConfig.stackSize" type="number" class="form-control" value="100">
                            </div>
                            
                            <div class="form-group">
                                <label>Small Blind</label>
                                <input v-model.number="newSimulation.gameConfig.smallBlind" type="number" class="form-control" value="0.5" step="0.1">
                            </div>
                            
                            <div class="form-group">
                                <label>Big Blind</label>
                                <input v-model.number="newSimulation.gameConfig.bigBlind" type="number" class="form-control" value="1" step="0.1">
                            </div>
                        </div>
                        
                        <div>
                            <h4>Configuration du solveur</h4>
                            <div class="form-group">
                                <label>It√©rations maximales</label>
                                <input v-model.number="newSimulation.solverConfig.maxIterations" type="number" class="form-control" value="1000">
                            </div>
                            
                            <div class="form-group">
                                <label>Exploitabilit√© cible (%)</label>
                                <input v-model.number="newSimulation.solverConfig.targetExploitability" type="number" class="form-control" value="0.5" step="0.1">
                            </div>
                            
                            <div class="form-group">
                                <label>Taille de batch</label>
                                <input v-model.number="newSimulation.solverConfig.batchSize" type="number" class="form-control" value="100">
                            </div>
                            
                            <div class="form-group">
                                <label>
                                    <input v-model="newSimulation.solverConfig.useChanceSampling" type="checkbox">
                                    Utiliser le chance sampling
                                </label>
                            </div>
                            
                            <div class="form-group">
                                <label>
                                    <input v-model="newSimulation.solverConfig.useDiscounting" type="checkbox">
                                    Utiliser le discounting
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <div v-if="createError" class="error">{{ createError }}</div>
                    <div v-if="createSuccess" class="success">{{ createSuccess }}</div>
                    
                    <button @click="createSimulation" class="btn btn-primary" :disabled="isCreating">
                        {{ isCreating ? 'Cr√©ation...' : 'D√©marrer la simulation' }}
                    </button>
                </div>
                
                <!-- Tab: Surveillance -->
                <div v-if="activeTab === 'monitor'">
                    <h3>Simulations en cours</h3>
                    
                    <div v-if="loadingSimulations" class="loading">
                        Chargement des simulations...
                    </div>
                    
                    <div v-for="simulation in activeSimulations" :key="simulation.simulation_id" class="simulation-item">
                        <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <h4>{{ simulation.name || simulation.simulation_id }}</h4>
                                <span class="status-badge" :class="'status-' + simulation.status">{{ simulation.status }}</span>
                            </div>
                            <button @click="cancelSimulation(simulation.simulation_id)" class="btn btn-danger" v-if="simulation.status === 'running'">
                                Annuler
                            </button>
                        </div>
                        
                        <div v-if="simulationStatuses[simulation.simulation_id]">
                            <div class="progress-bar">
                                <div class="progress-fill" :style="{width: simulationStatuses[simulation.simulation_id].progress_percentage + '%'}"></div>
                            </div>
                            <p style="margin-top: 5px; font-size: 14px; color: #666;">
                                Progr√®s: {{ simulationStatuses[simulation.simulation_id].progress_percentage.toFixed(1) }}% 
                                ({{ simulationStatuses[simulation.simulation_id].iterations_completed }} it√©rations)
                            </p>
                            <p v-if="simulationStatuses[simulation.simulation_id].current_exploitability" style="font-size: 14px; color: #666;">
                                Exploitabilit√© actuelle: {{ simulationStatuses[simulation.simulation_id].current_exploitability.toFixed(4) }}
                            </p>
                            <p v-if="simulationStatuses[simulation.simulation_id].estimated_time_remaining" style="font-size: 14px; color: #666;">
                                Temps restant estim√©: {{ formatTime(simulationStatuses[simulation.simulation_id].estimated_time_remaining) }}
                            </p>
                        </div>
                    </div>
                    
                    <div v-if="activeSimulations.length === 0 && !loadingSimulations">
                        <p style="text-align: center; color: #666; padding: 40px;">
                            Aucune simulation active
                        </p>
                    </div>
                </div>
                
                <!-- Tab: Cluster -->
                <div v-if="activeTab === 'cluster'">
                    <h3>‚ö° Cluster de Calcul Distribu√©</h3>
                    
                    <div class="cluster-overview">
                        <div class="cluster-stats" v-if="clusterStats">
                            <div class="stat-item">
                                <span class="stat-value">{{ clusterStats.active_nodes }}</span>
                                <span class="stat-label">N≈ìuds Actifs</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">{{ clusterStats.current_usage }}/{{ clusterStats.total_capacity }}</span>
                                <span class="stat-label">Utilisation</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">{{ clusterStats.utilization_percentage.toFixed(1) }}%</span>
                                <span class="stat-label">Charge</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">{{ clusterStats.pending_tasks }}</span>
                                <span class="stat-label">T√¢ches en Attente</span>
                            </div>
                        </div>
                        
                        <div class="cluster-actions">
                            <button @click="showClientInstructions = !showClientInstructions" class="btn btn-primary">
                                {{ showClientInstructions ? 'Masquer' : 'Ajouter un N≈ìud' }}
                            </button>
                            <button @click="refreshClusterData" class="btn btn-secondary">
                                Actualiser
                            </button>
                        </div>
                    </div>
                    
                    <div v-if="showClientInstructions" class="client-instructions">
                        <h4>üöÄ Comment ajouter votre ordinateur au cluster</h4>
                        <div class="instructions-content">
                            <p>Pour contribuer √† la puissance de calcul, t√©l√©chargez et ex√©cutez le client sur votre ordinateur :</p>
                            
                            <div class="instruction-step">
                                <strong>1. T√©l√©charger le client :</strong>
                                <div class="code-block">
                                    <code>curl -O http://{{ currentHost }}/download/compute_client.py</code>
                                    <button @click="copyToClipboard('curl -O http://' + currentHost + '/download/compute_client.py')" class="copy-btn">
                                        Copier
                                    </button>
                                </div>
                            </div>
                            
                            <div class="instruction-step">
                                <strong>2. Installer les d√©pendances :</strong>
                                <div class="code-block">
                                    <code>python3 compute_client.py --install</code>
                                    <button @click="copyToClipboard('python3 compute_client.py --install')" class="copy-btn">
                                        Copier
                                    </button>
                                </div>
                            </div>
                            
                            <div class="instruction-step">
                                <strong>3. D√©marrer le client :</strong>
                                <div class="code-block">
                                    <code>python3 compute_client.py --master-url http://{{ currentHost }}</code>
                                    <button @click="copyToClipboard('python3 compute_client.py --master-url http://' + currentHost)" class="copy-btn">
                                        Copier
                                    </button>
                                </div>
                            </div>
                            
                            <div class="options">
                                <h5>Options avanc√©es :</h5>
                                <ul>
                                    <li><code>--max-tasks N</code> : Nombre maximum de t√¢ches simultan√©es</li>
                                    <li><code>--node-id MON_ID</code> : ID personnalis√© pour ce n≈ìud</li>
                                    <li><code>--verbose</code> : Mode verbeux pour le debug</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <div class="compute-nodes-grid">
                        <div v-for="node in computeNodes" :key="node.node_id" class="compute-node-card">
                            <div class="node-header">
                                <h5>{{ node.node_id }}</h5>
                                <span class="status-badge" :class="'status-' + node.status">{{ node.status }}</span>
                            </div>
                            
                            <div class="node-info">
                                <div class="node-specs">
                                    <span><strong>Platform:</strong> {{ node.platform }} {{ node.architecture }}</span>
                                    <span><strong>CPUs:</strong> {{ node.cpu_count }}</span>
                                    <span><strong>M√©moire:</strong> {{ formatBytes(node.memory_total) }}</span>
                                </div>
                                
                                <div class="node-metrics">
                                    <div class="metric-row">
                                        <span>T√¢ches: {{ node.current_tasks }}/{{ node.max_concurrent_tasks }}</span>
                                        <div class="progress-bar">
                                            <div class="progress-fill" :style="{width: (node.current_tasks / node.max_concurrent_tasks * 100) + '%'}"></div>
                                        </div>
                                    </div>
                                    
                                    <div class="metric-row">
                                        <span>CPU: {{ node.cpu_usage ? node.cpu_usage.toFixed(1) : 0 }}%</span>
                                        <div class="progress-bar">
                                            <div class="progress-fill cpu" :style="{width: (node.cpu_usage || 0) + '%'}"></div>
                                        </div>
                                    </div>
                                    
                                    <div class="metric-row">
                                        <span>RAM: {{ node.memory_usage ? node.memory_usage.toFixed(1) : 0 }}%</span>
                                        <div class="progress-bar">
                                            <div class="progress-fill memory" :style="{width: (node.memory_usage || 0) + '%'}"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="node-stats">
                                    <small>
                                        Compl√©t√©es: {{ node.total_tasks_completed || 0 }} | 
                                        √âchou√©es: {{ node.total_tasks_failed || 0 }} |
                                        Derni√®re activit√©: {{ formatLastSeen(node.last_heartbeat) }}
                                    </small>
                                </div>
                            </div>
                        </div>
                        
                        <div v-if="computeNodes.length === 0" class="no-nodes">
                            <p>üîå Aucun n≈ìud de calcul connect√©</p>
                            <p>Ajoutez votre premier n≈ìud en suivant les instructions ci-dessus.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Tab: R√©sultats -->
                <div v-if="activeTab === 'results'">
                    <h3>R√©sultats des Simulations</h3>
                    
                    <div v-if="loadingResults" class="loading">
                        Chargement des r√©sultats...
                    </div>
                    
                    <div v-if="!loadingResults && completedSimulations.length === 0">
                        <p style="text-align: center; color: #666; padding: 40px;">
                            Aucune simulation termin√©e √† afficher.
                        </p>
                    </div>
                    
                    <div v-if="!loadingResults && completedSimulations.length > 0" class="results-layout">
                        <div class="results-list">
                            <h4>Simulations Termin√©es</h4>
                            <ul>
                                <li v-for="sim in completedSimulations" :key="sim.simulation_id" 
                                    @click="viewResults(sim.simulation_id)"
                                    :class="{ active: selectedSimulationResult && selectedSimulationResult.simulation_id === sim.simulation_id }">
                                    {{ sim.name || sim.simulation_id }} ({{ sim.status }})
                                    <br><small>{{ new Date(sim.completed_at).toLocaleString() }}</small>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="results-detail" v-if="selectedSimulationResult">
                            <h4>D√©tails de la Simulation: {{ selectedSimulationResult.name || selectedSimulationResult.simulation_id }}</h4>
                            <p><strong>ID:</strong> {{ selectedSimulationResult.simulation_id }}</p>
                            <p><strong>Type:</strong> {{ selectedSimulationResult.simulation_type }}</p>
                            <p><strong>Statut:</strong> {{ selectedSimulationResult.status }}</p>
                            <p><strong>Cr√©√©e le:</strong> {{ new Date(selectedSimulationResult.created_at).toLocaleString() }}</p>
                            <p><strong>Termin√©e le:</strong> {{ new Date(selectedSimulationResult.completed_at).toLocaleString() }}</p>
                            <p><strong>Dur√©e:</strong> {{ formatTime(selectedSimulationResult.duration_seconds) }}</p>
                            <p><strong>It√©rations:</strong> {{ selectedSimulationResult.iterations_completed }}</p>
                            <p><strong>Exploitabilit√© finale:</strong> {{ selectedSimulationResult.final_exploitability ? selectedSimulationResult.final_exploitability.toFixed(5) : 'N/A' }}</p>
                            
                            <!-- Ici, on pourrait int√©grer le StrategyVisualizer si les donn√©es sont disponibles -->
                            <div v-if="selectedSimulationResult.strategy_data">
                                <h5>Strat√©gie GTO</h5>
                                <!-- Assurez-vous que StrategyVisualizer est enregistr√© globalement ou localement -->
                                <!-- <strategy-visualizer :strategy="selectedSimulationResult.strategy_data"></strategy-visualizer> -->
                                <pre>{{ JSON.stringify(selectedSimulationResult.strategy_data, null, 2) }}</pre>
                            </div>
                            <div v-else>
                                <p>Aucune donn√©e de strat√©gie disponible pour cette simulation.</p>
                            </div>
                             <button @click="ApiGateway.exportStrategyAsJson(selectedSimulationResult.strategy_data)" class="btn btn-secondary" v-if="selectedSimulationResult.strategy_data">
                                Exporter la strat√©gie (JSON)
                            </button>
                        </div>
                         <div class="results-detail" v-else>
                            <p style="text-align: center; color: #666; padding: 40px;">
                                S√©lectionnez une simulation pour voir les d√©tails.
                            </p>
                        </div>
                    </div>
                </div>
                
                <div v-if="activeTab === 'status'">
                    <h3>Statut du syst√®me</h3>
                    
                    <div class="grid">
                        <div>
                            <h4>N≈ìud Ma√Ætre</h4>
                            <div v-if="systemStatus">
                                <p><strong>Statut:</strong> {{ systemStatus.status }}</p>
                                <p><strong>Simulations actives:</strong> {{ systemStatus.active_simulations }}</p>
                                <p><strong>Derni√®re mise √† jour:</strong> {{ new Date(systemStatus.timestamp).toLocaleString() }}</p>
                            </div>
                        </div>
                        
                        <div>
                            <h4>Files de messages</h4>
                            <div v-if="queueStatus">
                                <p><strong>T√¢ches pr√©flop:</strong> {{ queueStatus.preflop_tasks }}</p>
                                <p><strong>T√¢ches postflop:</strong> {{ queueStatus.postflop_tasks }}</p>
                                <p><strong>R√©sultats en attente:</strong> {{ queueStatus.pending_results }}</p>
                                <p><strong>Connexion:</strong> {{ queueStatus.connected ? 'Connect√©' : 'D√©connect√©' }}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4>N≈ìuds de calcul</h4>
                        <div v-if="computeNodes && computeNodes.length > 0">
                            <div v-for="node in computeNodes" :key="node.node_id" class="simulation-item">
                                <h5>{{ node.node_id }}</h5>
                                <p><strong>Statut:</strong> {{ node.status }}</p>
                                <p><strong>T√¢ches actives:</strong> {{ node.current_tasks }} / {{ node.total_capacity }}</p>
                                <p><strong>Dernier heartbeat:</strong> {{ new Date(node.last_heartbeat).toLocaleString() }}</p>
                            </div>
                        </div>
                        <div v-else>
                            <p style="color: #666;">Aucun n≈ìud de calcul disponible</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;
        
        createApp({
            data() {
                return {
                    activeTab: 'create',
                    
                    // Nouvelle simulation
                    newSimulation: {
                        type: 'preflop',
                        name: '',
                        description: '',
                        gameConfig: {
                            numPlayers: 2,
                            stackSize: 100,
                            smallBlind: 0.5,
                            bigBlind: 1.0
                        },
                        solverConfig: {
                            maxIterations: 1000,
                            targetExploitability: 0.5,
                            batchSize: 100,
                            useChanceSampling: true,
                            useDiscounting: true
                        }
                    },
                    isCreating: false,
                    createError: '',
                    createSuccess: '',
                    
                    // Surveillance
                    activeSimulations: [],
                    simulationStatuses: {},
                    loadingSimulations: false,
                    
                    // Syst√®me
                    systemStatus: null,
                    queueStatus: null,
                    computeNodes: [],
                    clusterStats: null,
                    
                    // Monitoring temps r√©el
                    realtimeMonitor: null,
                    isRealtimeConnected: false,
                    
                    // Cluster
                    showClientInstructions: false,
                    
                    // Polling
                    statusInterval: null,

                    // R√©sultats
                    completedSimulations: [],
                    simulationResults: {},
                    loadingResults: false,
                    selectedSimulationResult: null
                }
            },
            
            computed: {
                currentHost() {
                    return window.location.host;
                }
            },
            
            async mounted() {
                console.log('Vue app mounting...');
                
                // Initialiser le monitoring temps r√©el
                this.initRealtimeMonitoring();
                
                try {
                    await this.loadSystemStatus();
                    console.log('System status loaded');
                } catch (error) {
                    console.error('Failed to load system status:', error);
                }
                
                try {
                    await this.loadSimulations();
                    console.log('Simulations loaded');
                } catch (error) {
                    console.error('Failed to load simulations:', error);
                }
                
                this.startStatusPolling();
                this.loadCompletedSimulations(); // Charger les r√©sultats au montage
                console.log('Vue app mounted successfully');
            },
            
            beforeUnmount() {
                if (this.statusInterval) {
                    clearInterval(this.statusInterval);
                }
                
                if (this.realtimeMonitor) {
                    this.realtimeMonitor.disconnect();
                }
            },
            
            methods: {
                // Monitoring temps r√©el
                initRealtimeMonitoring() {
                    this.realtimeMonitor = new RealtimeMonitor();
                    
                    // √âcouter les √©v√©nements de connexion
                    this.realtimeMonitor.on('connected', (data) => {
                        this.isRealtimeConnected = data.connected;
                    });
                    
                    // √âcouter les mises √† jour des simulations
                    this.realtimeMonitor.on('simulation_update', (data) => {
                        this.handleSimulationUpdate(data);
                    });
                    
                    // √âcouter les mises √† jour syst√®me
                    this.realtimeMonitor.on('system_update', (data) => {
                        this.handleSystemUpdate(data);
                    });
                    
                    // √âcouter les mises √† jour des n≈ìuds de calcul
                    this.realtimeMonitor.on('compute_node_update', (data) => {
                        this.handleComputeNodeUpdate(data);
                    });
                },
                
                handleSimulationUpdate(data) {
                    const { simulation_id, status, progress_percentage, iterations_completed, 
                           current_exploitability, estimated_time_remaining } = data;
                    
                    // Mettre √† jour le statut de simulation
                    this.simulationStatuses[simulation_id] = {
                        ...this.simulationStatuses[simulation_id],
                        status,
                        progress_percentage,
                        iterations_completed,
                        current_exploitability,
                        estimated_time_remaining
                    };
                    
                    // Si la simulation est termin√©e, recharger la liste et les r√©sultats
                    if (status === 'completed' || status === 'failed') {
                        this.loadSimulations();
                        if (this.activeTab === 'results') {
                             this.loadCompletedSimulations();
                        }
                    }
                    
                    console.log(`Simulation ${simulation_id} mise √† jour:`, data);
                },
                
                handleSystemUpdate(data) {
                    if (data.queue_status) {
                        this.queueStatus = { ...this.queueStatus, ...data.queue_status };
                    }
                    
                    if (data.compute_nodes) {
                        this.computeNodes = data.compute_nodes;
                    }
                    
                    console.log('Syst√®me mis √† jour:', data);
                },
                
                handleComputeNodeUpdate(data) {
                    if (data.event === 'node_connected') {
                        // Ajouter le nouveau n≈ìud s'il n'existe pas
                        const existingIndex = this.computeNodes.findIndex(n => n.node_id === data.node.node_id);
                        if (existingIndex === -1) {
                            this.computeNodes.push(data.node);
                        }
                        this.refreshClusterData();
                    } else if (data.event === 'node_disconnected') {
                        // Supprimer le n≈ìud d√©connect√©
                        this.computeNodes = this.computeNodes.filter(n => n.node_id !== data.node_id);
                        this.refreshClusterData();
                    }
                    
                    console.log('N≈ìud de calcul mis √† jour:', data);
                },
                async createSimulation() {
                    this.isCreating = true;
                    this.createError = '';
                    this.createSuccess = '';
                    
                    try {
                        // Utiliser l'API Gateway
                        const requestData = ApiGateway.formatSimulationForSubmission(this.newSimulation);
                        const response = await ApiGateway.createSimulation(requestData);
                        
                        this.createSuccess = `Simulation cr√©√©e avec succ√®s: ${response.data.simulation_id}`;
                        
                        // R√©initialiser le formulaire
                        this.newSimulation.name = '';
                        this.newSimulation.description = '';
                        
                        // Recharger les simulations
                        await this.loadSimulations();
                        
                        // S'abonner aux mises √† jour de la nouvelle simulation
                        if (this.realtimeMonitor) {
                            this.realtimeMonitor.subscribeToSimulation(response.data.simulation_id);
                        }
                        
                        // Basculer vers l'onglet surveillance
                        this.activeTab = 'monitor';
                        
                    } catch (error) {
                        this.createError = error.response?.data?.detail || 'Erreur lors de la cr√©ation de la simulation';
                    } finally {
                        this.isCreating = false;
                    }
                },
                
                async loadCompletedSimulations() {
                    this.loadingResults = true;
                    try {
                        const response = await ApiGateway.listSimulations({ status: 'completed' });
                        this.completedSimulations = response.data;
                        // Optionnel: pr√©charger les d√©tails des r√©sultats pour chaque simulation
                        // for (const sim of this.completedSimulations) {
                        //     await this.loadSimulationResultDetails(sim.simulation_id);
                        // }
                    } catch (error) {
                        console.error('Erreur lors du chargement des simulations termin√©es:', error);
                    } finally {
                        this.loadingResults = false;
                    }
                },

                async loadSimulationResultDetails(simulationId) {
                    if (this.simulationResults[simulationId]) {
                        this.selectedSimulationResult = this.simulationResults[simulationId];
                        return;
                    }
                    this.loadingResults = true;
                    try {
                        const response = await ApiGateway.getSimulationResults(simulationId);
                        this.simulationResults[simulationId] = response.data;
                        this.selectedSimulationResult = response.data;
                    } catch (error) {
                        console.error(`Erreur lors du chargement des r√©sultats pour ${simulationId}:`, error);
                        alert(`Impossible de charger les r√©sultats pour la simulation ${simulationId}`);
                        this.selectedSimulationResult = null;
                    } finally {
                        this.loadingResults = false;
                    }
                },

                async viewResults(simulationId) {
                    this.activeTab = 'results'; // S'assurer que l'onglet est actif
                    await this.loadSimulationResultDetails(simulationId);
                    // Ici, on pourrait int√©grer ou naviguer vers une vue d√©taill√©e des r√©sultats
                    // Pour l'instant, on stocke juste dans selectedSimulationResult
                },
                
                async loadSimulations() {
                    this.loadingSimulations = true;
                    
                    try {
                        // Charger les simulations actives
                        const activeResponse = await ApiGateway.listSimulations({status: 'running'});
                        const pendingResponse = await ApiGateway.listSimulations({status: 'pending'});
                        this.activeSimulations = [...activeResponse.data, ...pendingResponse.data];
                        
                        // Charger le statut d√©taill√© des simulations actives
                        for (const sim of this.activeSimulations) {
                            await this.loadSimulationStatus(sim.simulation_id);
                            
                            // S'abonner aux mises √† jour temps r√©el
                            if (this.realtimeMonitor) {
                                this.realtimeMonitor.subscribeToSimulation(sim.simulation_id);
                            }
                        }
                        
                    } catch (error) {
                        console.error('Erreur lors du chargement des simulations:', error);
                    } finally {
                        this.loadingSimulations = false;
                    }
                },
                
                async loadSimulationStatus(simulationId) {
                    try {
                        const response = await ApiGateway.getSimulationStatus(simulationId);
                        this.simulationStatuses[simulationId] = response.data;
                    } catch (error) {
                        console.error(`Erreur lors du chargement du statut de ${simulationId}:`, error);
                    }
                },
                
                async cancelSimulation(simulationId) {
                    if (!confirm('√ätes-vous s√ªr de vouloir annuler cette simulation ?')) {
                        return;
                    }
                    
                    try {
                        await ApiGateway.cancelSimulation(simulationId);
                        await this.loadSimulations();
                    } catch (error) {
                        alert('Erreur lors de l\'annulation de la simulation');
                    }
                },
                
                async loadSystemStatus() {
                    try {
                        const [statusResponse, queueResponse, nodesResponse] = await Promise.all([
                            ApiGateway.getSystemStatus(),
                            ApiGateway.getQueueStatus(),
                            ApiGateway.getComputeNodes()
                        ]);
                        
                        this.systemStatus = statusResponse.data;
                        this.queueStatus = queueResponse.data;
                        this.computeNodes = nodesResponse.data.compute_nodes || [];
                        this.clusterStats = nodesResponse.data.cluster_stats;
                        
                    } catch (error) {
                        console.error('Erreur lors du chargement du statut syst√®me:', error);
                    }
                },
                
                async refreshClusterData() {
                    try {
                        const nodesResponse = await ApiGateway.getComputeNodes();
                        this.computeNodes = nodesResponse.data.compute_nodes || [];
                        this.clusterStats = nodesResponse.data.cluster_stats;
                    } catch (error) {
                        console.error('Erreur lors du rafra√Æchissement du cluster:', error);
                    }
                },
                
                // Utilitaires pour l'affichage
                formatBytes(bytes) {
                    return MonitoringUtils.formatBytes(bytes);
                },
                
                formatLastSeen(dateString) {
                    if (!dateString) return 'Jamais';
                    
                    const date = new Date(dateString);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    
                    if (diffMins < 1) return '√Ä l\'instant';
                    if (diffMins < 60) return `Il y a ${diffMins}min`;
                    
                    const diffHours = Math.floor(diffMins / 60);
                    if (diffHours < 24) return `Il y a ${diffHours}h`;
                    
                    const diffDays = Math.floor(diffHours / 24);
                    return `Il y a ${diffDays}j`;
                },
                
                copyToClipboard(text) {
                    navigator.clipboard.writeText(text).then(() => {
                        // Afficher une notification de succ√®s
                        const notification = document.createElement('div');
                        notification.textContent = 'Copi√© dans le presse-papiers !';
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: #28a745;
                            color: white;
                            padding: 10px 15px;
                            border-radius: 5px;
                            z-index: 1000;
                            font-family: Arial, sans-serif;
                        `;
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            document.body.removeChild(notification);
                        }, 2000);
                    }).catch(err => {
                        console.error('Erreur lors de la copie:', err);
                        alert('Erreur lors de la copie dans le presse-papiers');
                    });
                },
                
                startStatusPolling() {
                    this.statusInterval = setInterval(async () => {
                        await this.loadSystemStatus();
                        
                        // Mettre √† jour le statut des simulations actives
                        for (const sim of this.activeSimulations) {
                            await this.loadSimulationStatus(sim.simulation_id);
                        }
                        
                        // Recharger automatiquement la liste si n√©cessaire
                        if (this.activeSimulations.some(sim => 
                            this.simulationStatuses[sim.simulation_id]?.status === 'completed')) {
                            await this.loadSimulations();
                        }
                    }, 5000); // Toutes les 5 secondes
                },
                
                formatTime(seconds) {
                    if (!seconds) return '0s';
                    
                    if (seconds < 60) {
                        return `${Math.round(seconds)}s`;
                    } else if (seconds < 3600) {
                        return `${Math.floor(seconds / 60)}min ${Math.round(seconds % 60)}s`;
                    } else {
                        return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}min`;
                    }
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
